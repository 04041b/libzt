/* automatically generated by rust-bindgen 0.57.0 */

pub const ZTS_MAC_ADDRSTRLEN: u32 = 18;
pub const ZTS_INET_ADDRSTRLEN: u32 = 16;
pub const ZTS_INET6_ADDRSTRLEN: u32 = 46;
pub const ZTS_IP_MAX_STR_LEN: u32 = 46;
pub const ZTS_STORE_DATA_LEN: u32 = 4096;
pub const ZTS_MAX_NETWORK_SHORT_NAME_LENGTH: u32 = 127;
pub const ZTS_MAX_NETWORK_ROUTES: u32 = 32;
pub const ZTS_MAX_ASSIGNED_ADDRESSES: u32 = 16;
pub const ZTS_MAX_PEER_NETWORK_PATHS: u32 = 16;
pub const ZTS_MAX_MULTICAST_SUBSCRIPTIONS: u32 = 1024;
pub const ZTS_MAX_ENDPOINT_STR_LEN: u32 = 52;
pub const ZTS_C_API_ONLY: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 110300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const ZTS_SOCK_STREAM: u32 = 1;
pub const ZTS_SOCK_DGRAM: u32 = 2;
pub const ZTS_SOCK_RAW: u32 = 3;
pub const ZTS_AF_UNSPEC: u32 = 0;
pub const ZTS_AF_INET: u32 = 2;
pub const ZTS_AF_INET6: u32 = 10;
pub const ZTS_PF_INET: u32 = 2;
pub const ZTS_PF_INET6: u32 = 10;
pub const ZTS_PF_UNSPEC: u32 = 0;
pub const ZTS_IPPROTO_IP: u32 = 0;
pub const ZTS_IPPROTO_ICMP: u32 = 1;
pub const ZTS_IPPROTO_TCP: u32 = 6;
pub const ZTS_IPPROTO_UDP: u32 = 17;
pub const ZTS_IPPROTO_IPV6: u32 = 41;
pub const ZTS_IPPROTO_ICMPV6: u32 = 58;
pub const ZTS_IPPROTO_UDPLITE: u32 = 136;
pub const ZTS_IPPROTO_RAW: u32 = 255;
pub const ZTS_MSG_PEEK: u32 = 1;
pub const ZTS_MSG_WAITALL: u32 = 2;
pub const ZTS_MSG_OOB: u32 = 4;
pub const ZTS_MSG_DONTWAIT: u32 = 8;
pub const ZTS_MSG_MORE: u32 = 16;
pub const ZTS_IOCPARM_MASK: u32 = 127;
pub const ZTS_IOC_VOID: u32 = 536870912;
pub const ZTS_IOC_OUT: u32 = 1073741824;
pub const ZTS_IOC_IN: u32 = 2147483648;
pub const ZTS_IOC_INOUT: u32 = 3221225472;
pub const SIN_ZERO_LEN: u32 = 8;
pub const ZTS_MAX_NUM_ROOTS: u32 = 16;
pub const ZTS_MAX_ENDPOINTS_PER_ROOT: u32 = 32;
pub const ZTS_DISABLE_CENTRAL_API: u32 = 1;
pub const ZTS_ID_STR_BUF_LEN: u32 = 384;
pub const ZTS_SOL_SOCKET: u32 = 4095;
pub const ZTS_SO_DEBUG: u32 = 1;
pub const ZTS_SO_ACCEPTCONN: u32 = 2;
pub const ZTS_SO_REUSEADDR: u32 = 4;
pub const ZTS_SO_KEEPALIVE: u32 = 8;
pub const ZTS_SO_DONTROUTE: u32 = 16;
pub const ZTS_SO_BROADCAST: u32 = 32;
pub const ZTS_SO_USELOOPBACK: u32 = 64;
pub const ZTS_SO_LINGER: u32 = 128;
pub const ZTS_SO_OOBINLINE: u32 = 256;
pub const ZTS_SO_REUSEPORT: u32 = 512;
pub const ZTS_SO_SNDBUF: u32 = 4097;
pub const ZTS_SO_RCVBUF: u32 = 4098;
pub const ZTS_SO_SNDLOWAT: u32 = 4099;
pub const ZTS_SO_RCVLOWAT: u32 = 4100;
pub const ZTS_SO_SNDTIMEO: u32 = 4101;
pub const ZTS_SO_RCVTIMEO: u32 = 4102;
pub const ZTS_SO_ERROR: u32 = 4103;
pub const ZTS_SO_TYPE: u32 = 4104;
pub const ZTS_SO_CONTIMEO: u32 = 4105;
pub const ZTS_SO_NO_CHECK: u32 = 4106;
pub const ZTS_SO_BINDTODEVICE: u32 = 4107;
pub const ZTS_IP_TOS: u32 = 1;
pub const ZTS_IP_TTL: u32 = 2;
pub const ZTS_IP_PKTINFO: u32 = 8;
pub const ZTS_TCP_NODELAY: u32 = 1;
pub const ZTS_TCP_KEEPALIVE: u32 = 2;
pub const ZTS_TCP_KEEPIDLE: u32 = 3;
pub const ZTS_TCP_KEEPINTVL: u32 = 4;
pub const ZTS_TCP_KEEPCNT: u32 = 5;
pub const ZTS_IPV6_CHECKSUM: u32 = 7;
pub const ZTS_IPV6_V6ONLY: u32 = 27;
pub const ZTS_UDPLITE_SEND_CSCOV: u32 = 1;
pub const ZTS_UDPLITE_RECV_CSCOV: u32 = 2;
pub const ZTS_IP_MULTICAST_TTL: u32 = 5;
pub const ZTS_IP_MULTICAST_IF: u32 = 6;
pub const ZTS_IP_MULTICAST_LOOP: u32 = 7;
pub const ZTS_IP_ADD_MEMBERSHIP: u32 = 3;
pub const ZTS_IP_DROP_MEMBERSHIP: u32 = 4;
pub const ZTS_IPV6_JOIN_GROUP: u32 = 12;
pub const ZTS_IPV6_ADD_MEMBERSHIP: u32 = 12;
pub const ZTS_IPV6_LEAVE_GROUP: u32 = 13;
pub const ZTS_IPV6_DROP_MEMBERSHIP: u32 = 13;
pub const ZTS_IPTOS_TOS_MASK: u32 = 30;
pub const ZTS_IPTOS_LOWDELAY: u32 = 16;
pub const ZTS_IPTOS_THROUGHPUT: u32 = 8;
pub const ZTS_IPTOS_RELIABILITY: u32 = 4;
pub const ZTS_IPTOS_LOWCOST: u32 = 2;
pub const ZTS_IPTOS_MINCOST: u32 = 2;
pub const ZTS_IPTOS_PREC_MASK: u32 = 224;
pub const ZTS_IPTOS_PREC_NETCONTROL: u32 = 224;
pub const ZTS_IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const ZTS_IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const ZTS_IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const ZTS_IPTOS_PREC_FLASH: u32 = 96;
pub const ZTS_IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const ZTS_IPTOS_PREC_PRIORITY: u32 = 32;
pub const ZTS_IPTOS_PREC_ROUTINE: u32 = 0;
pub const LWIP_SOCKET_OFFSET: u32 = 0;
pub const MEMP_NUM_NETCONN: u32 = 1024;
pub const ZTS_FD_SETSIZE: u32 = 1024;
pub const ZTS_F_GETFL: u32 = 3;
pub const ZTS_F_SETFL: u32 = 4;
pub const ZTS_O_NONBLOCK: u32 = 1;
pub const ZTS_O_NDELAY: u32 = 1;
pub const ZTS_O_RDONLY: u32 = 2;
pub const ZTS_O_WRONLY: u32 = 4;
pub const ZTS_O_RDWR: u32 = 6;
pub const ZTS_POLLIN: u32 = 1;
pub const ZTS_POLLOUT: u32 = 2;
pub const ZTS_POLLERR: u32 = 4;
pub const ZTS_POLLNVAL: u32 = 8;
pub const ZTS_POLLRDNORM: u32 = 16;
pub const ZTS_POLLRDBAND: u32 = 32;
pub const ZTS_POLLPRI: u32 = 64;
pub const ZTS_POLLWRNORM: u32 = 128;
pub const ZTS_POLLWRBAND: u32 = 256;
pub const ZTS_POLLHUP: u32 = 512;
pub const ZTS_MSG_TRUNC: u32 = 4;
pub const ZTS_MSG_CTRUNC: u32 = 8;
pub const ZTS_SHUT_RD: u32 = 0;
pub const ZTS_SHUT_WR: u32 = 1;
pub const ZTS_SHUT_RDWR: u32 = 2;
#[doc = " No error"]
pub const zts_error_t_ZTS_ERR_OK: zts_error_t = 0;
#[doc = " Socket error, see `zts_errno`"]
pub const zts_error_t_ZTS_ERR_SOCKET: zts_error_t = -1;
#[doc = " This operation is not allowed at this time. Or possibly the node hasn't been started"]
pub const zts_error_t_ZTS_ERR_SERVICE: zts_error_t = -2;
#[doc = " Invalid argument"]
pub const zts_error_t_ZTS_ERR_ARG: zts_error_t = -3;
#[doc = " No result (not necessarily an error)"]
pub const zts_error_t_ZTS_ERR_NO_RESULT: zts_error_t = -4;
#[doc = " Consider filing a bug report"]
pub const zts_error_t_ZTS_ERR_GENERAL: zts_error_t = -5;
#[doc = " Common error return values"]
pub type zts_error_t = ::std::os::raw::c_int;
#[doc = " Node has been initialized"]
#[doc = ""]
#[doc = " This is the first event generated, and is always sent. It may occur"]
#[doc = " before node's constructor returns."]
#[doc = ""]
pub const zts_event_t_ZTS_EVENT_NODE_UP: zts_event_t = 200;
#[doc = " Node is online -- at least one upstream node appears reachable"]
#[doc = ""]
pub const zts_event_t_ZTS_EVENT_NODE_ONLINE: zts_event_t = 201;
#[doc = " Node is offline -- network does not seem to be reachable by any available"]
#[doc = " strategy"]
#[doc = ""]
pub const zts_event_t_ZTS_EVENT_NODE_OFFLINE: zts_event_t = 202;
#[doc = " Node is shutting down"]
#[doc = ""]
#[doc = " This is generated within Node's destructor when it is being shut down."]
#[doc = " It's done for convenience, since cleaning up other state in the event"]
#[doc = " handler may appear more idiomatic."]
#[doc = ""]
pub const zts_event_t_ZTS_EVENT_NODE_DOWN: zts_event_t = 203;
#[doc = " A fatal error has occurred. One possible reason is:"]
#[doc = ""]
#[doc = " Your identity has collided with another node's ZeroTier address"]
#[doc = ""]
#[doc = " This happens if two different public keys both hash (via the algorithm"]
#[doc = " in Identity::generate()) to the same 40-bit ZeroTier address."]
#[doc = ""]
#[doc = " This is something you should \"never\" see, where \"never\" is defined as"]
#[doc = " once per 2^39 new node initializations / identity creations. If you do"]
#[doc = " see it, you're going to see it very soon after a node is first"]
#[doc = " initialized."]
#[doc = ""]
#[doc = " This is reported as an event rather than a return code since it's"]
#[doc = " detected asynchronously via error messages from authoritative nodes."]
#[doc = ""]
#[doc = " If this occurs, you must shut down and delete the node, delete the"]
#[doc = " identity.secret record/file from the data store, and restart to generate"]
#[doc = " a new identity. If you don't do this, you will not be able to communicate"]
#[doc = " with other nodes."]
#[doc = ""]
#[doc = " We'd automate this process, but we don't think silently deleting"]
#[doc = " private keys or changing our address without telling the calling code"]
#[doc = " is good form. It violates the principle of least surprise."]
#[doc = ""]
#[doc = " You can technically get away with not handling this, but we recommend"]
#[doc = " doing so in a mature reliable application. Besides, handling this"]
#[doc = " condition is a good way to make sure it never arises. It's like how"]
#[doc = " umbrellas prevent rain and smoke detectors prevent fires. They do, right?"]
#[doc = ""]
#[doc = " Meta-data: none"]
pub const zts_event_t_ZTS_EVENT_NODE_FATAL_ERROR: zts_event_t = 204;
#[doc = " Network ID does not correspond to a known network"]
pub const zts_event_t_ZTS_EVENT_NETWORK_NOT_FOUND: zts_event_t = 210;
#[doc = " The version of ZeroTier inside libzt is too old"]
pub const zts_event_t_ZTS_EVENT_NETWORK_CLIENT_TOO_OLD: zts_event_t = 211;
#[doc = " The configuration for a network has been requested (no action needed)"]
pub const zts_event_t_ZTS_EVENT_NETWORK_REQ_CONFIG: zts_event_t = 212;
#[doc = " The node joined the network successfully (no action needed)"]
pub const zts_event_t_ZTS_EVENT_NETWORK_OK: zts_event_t = 213;
#[doc = " The node is not allowed to join the network (you must authorize node)"]
pub const zts_event_t_ZTS_EVENT_NETWORK_ACCESS_DENIED: zts_event_t = 214;
#[doc = " The node has received an IPv4 address from the network controller"]
pub const zts_event_t_ZTS_EVENT_NETWORK_READY_IP4: zts_event_t = 215;
#[doc = " The node has received an IPv6 address from the network controller"]
pub const zts_event_t_ZTS_EVENT_NETWORK_READY_IP6: zts_event_t = 216;
#[doc = " Deprecated"]
pub const zts_event_t_ZTS_EVENT_NETWORK_READY_IP4_IP6: zts_event_t = 217;
#[doc = " Network controller is unreachable"]
pub const zts_event_t_ZTS_EVENT_NETWORK_DOWN: zts_event_t = 218;
#[doc = " Network change received from controller"]
pub const zts_event_t_ZTS_EVENT_NETWORK_UPDATE: zts_event_t = 219;
#[doc = " TCP/IP stack (lwIP) is up (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_STACK_UP: zts_event_t = 220;
#[doc = " TCP/IP stack (lwIP) id down (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_STACK_DOWN: zts_event_t = 221;
#[doc = " lwIP netif up (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_NETIF_UP: zts_event_t = 230;
#[doc = " lwIP netif down (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_NETIF_DOWN: zts_event_t = 231;
#[doc = " lwIP netif removed (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_NETIF_REMOVED: zts_event_t = 232;
#[doc = " lwIP netif link up (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_NETIF_LINK_UP: zts_event_t = 233;
#[doc = " lwIP netif link down (for debug purposes)"]
pub const zts_event_t_ZTS_EVENT_NETIF_LINK_DOWN: zts_event_t = 234;
#[doc = " A direct P2P path to peer is known"]
pub const zts_event_t_ZTS_EVENT_PEER_DIRECT: zts_event_t = 240;
#[doc = " A direct P2P path to peer is NOT known. Traffic is now relayed"]
pub const zts_event_t_ZTS_EVENT_PEER_RELAY: zts_event_t = 241;
#[doc = " A peer is unreachable. Check NAT/Firewall settings"]
pub const zts_event_t_ZTS_EVENT_PEER_UNREACHABLE: zts_event_t = 242;
#[doc = " A new path to a peer was discovered"]
pub const zts_event_t_ZTS_EVENT_PEER_PATH_DISCOVERED: zts_event_t = 243;
#[doc = " A known path to a peer is now considered dead"]
pub const zts_event_t_ZTS_EVENT_PEER_PATH_DEAD: zts_event_t = 244;
#[doc = " A new managed network route was added"]
pub const zts_event_t_ZTS_EVENT_ROUTE_ADDED: zts_event_t = 250;
#[doc = " A managed network route was removed"]
pub const zts_event_t_ZTS_EVENT_ROUTE_REMOVED: zts_event_t = 251;
#[doc = " A new managed IPv4 address was assigned to this peer"]
pub const zts_event_t_ZTS_EVENT_ADDR_ADDED_IP4: zts_event_t = 260;
#[doc = " A managed IPv4 address assignment was removed from this peer"]
pub const zts_event_t_ZTS_EVENT_ADDR_REMOVED_IP4: zts_event_t = 261;
#[doc = " A new managed IPv4 address was assigned to this peer"]
pub const zts_event_t_ZTS_EVENT_ADDR_ADDED_IP6: zts_event_t = 262;
#[doc = " A managed IPv6 address assignment was removed from this peer"]
pub const zts_event_t_ZTS_EVENT_ADDR_REMOVED_IP6: zts_event_t = 263;
#[doc = " The node's secret key (identity)"]
pub const zts_event_t_ZTS_EVENT_STORE_IDENTITY_SECRET: zts_event_t = 270;
#[doc = " The node's public key (identity)"]
pub const zts_event_t_ZTS_EVENT_STORE_IDENTITY_PUBLIC: zts_event_t = 271;
#[doc = " The node has received an updated planet config"]
pub const zts_event_t_ZTS_EVENT_STORE_PLANET: zts_event_t = 272;
#[doc = " New reachability hints and peer configuration"]
pub const zts_event_t_ZTS_EVENT_STORE_PEER: zts_event_t = 273;
#[doc = " New network config"]
pub const zts_event_t_ZTS_EVENT_STORE_NETWORK: zts_event_t = 274;
#[doc = " Event codes used by the (optional) callback API"]
pub type zts_event_t = ::std::os::raw::c_uint;
extern "C" {
    pub static mut zts_errno: ::std::os::raw::c_int;
}
#[doc = " Operation not permitted"]
pub const zts_errno_t_ZTS_EPERM: zts_errno_t = 1;
#[doc = " No such file or directory"]
pub const zts_errno_t_ZTS_ENOENT: zts_errno_t = 2;
#[doc = " No such process"]
pub const zts_errno_t_ZTS_ESRCH: zts_errno_t = 3;
#[doc = " Interrupted system call"]
pub const zts_errno_t_ZTS_EINTR: zts_errno_t = 4;
#[doc = " I/O error"]
pub const zts_errno_t_ZTS_EIO: zts_errno_t = 5;
#[doc = " No such device or address"]
pub const zts_errno_t_ZTS_ENXIO: zts_errno_t = 6;
#[doc = " Bad file number"]
pub const zts_errno_t_ZTS_EBADF: zts_errno_t = 9;
#[doc = " Try again"]
pub const zts_errno_t_ZTS_EAGAIN: zts_errno_t = 11;
#[doc = " Operation would block"]
pub const zts_errno_t_ZTS_EWOULDBLOCK: zts_errno_t = 11;
#[doc = " Out of memory"]
pub const zts_errno_t_ZTS_ENOMEM: zts_errno_t = 12;
#[doc = " Permission denied"]
pub const zts_errno_t_ZTS_EACCES: zts_errno_t = 13;
#[doc = " Bad address"]
pub const zts_errno_t_ZTS_EFAULT: zts_errno_t = 14;
#[doc = " Device or resource busy"]
pub const zts_errno_t_ZTS_EBUSY: zts_errno_t = 16;
#[doc = " File exists"]
pub const zts_errno_t_ZTS_EEXIST: zts_errno_t = 17;
#[doc = " No such device"]
pub const zts_errno_t_ZTS_ENODEV: zts_errno_t = 19;
#[doc = " Invalid argument"]
pub const zts_errno_t_ZTS_EINVAL: zts_errno_t = 22;
#[doc = " File table overflow"]
pub const zts_errno_t_ZTS_ENFILE: zts_errno_t = 23;
#[doc = " Too many open files"]
pub const zts_errno_t_ZTS_EMFILE: zts_errno_t = 24;
#[doc = " Function not implemented"]
pub const zts_errno_t_ZTS_ENOSYS: zts_errno_t = 38;
#[doc = " Socket operation on non-socket"]
pub const zts_errno_t_ZTS_ENOTSOCK: zts_errno_t = 88;
#[doc = " Destination address required"]
pub const zts_errno_t_ZTS_EDESTADDRREQ: zts_errno_t = 89;
#[doc = " Message too long"]
pub const zts_errno_t_ZTS_EMSGSIZE: zts_errno_t = 90;
#[doc = " Protocol wrong type for socket"]
pub const zts_errno_t_ZTS_EPROTOTYPE: zts_errno_t = 91;
#[doc = " Protocol not available"]
pub const zts_errno_t_ZTS_ENOPROTOOPT: zts_errno_t = 92;
#[doc = " Protocol not supported"]
pub const zts_errno_t_ZTS_EPROTONOSUPPORT: zts_errno_t = 93;
#[doc = " Socket type not supported"]
pub const zts_errno_t_ZTS_ESOCKTNOSUPPORT: zts_errno_t = 94;
#[doc = " Operation not supported on transport endpoint"]
pub const zts_errno_t_ZTS_EOPNOTSUPP: zts_errno_t = 95;
#[doc = " Protocol family not supported"]
pub const zts_errno_t_ZTS_EPFNOSUPPORT: zts_errno_t = 96;
#[doc = " Address family not supported by protocol"]
pub const zts_errno_t_ZTS_EAFNOSUPPORT: zts_errno_t = 97;
#[doc = " Address already in use"]
pub const zts_errno_t_ZTS_EADDRINUSE: zts_errno_t = 98;
#[doc = " Cannot assign requested address"]
pub const zts_errno_t_ZTS_EADDRNOTAVAIL: zts_errno_t = 99;
#[doc = " Network is down"]
pub const zts_errno_t_ZTS_ENETDOWN: zts_errno_t = 100;
#[doc = " Network is unreachable"]
pub const zts_errno_t_ZTS_ENETUNREACH: zts_errno_t = 101;
#[doc = " Software caused connection abort"]
pub const zts_errno_t_ZTS_ECONNABORTED: zts_errno_t = 103;
#[doc = " Connection reset by peer"]
pub const zts_errno_t_ZTS_ECONNRESET: zts_errno_t = 104;
#[doc = " No buffer space available"]
pub const zts_errno_t_ZTS_ENOBUFS: zts_errno_t = 105;
#[doc = " Transport endpoint is already connected"]
pub const zts_errno_t_ZTS_EISCONN: zts_errno_t = 106;
#[doc = " Transport endpoint is not connected"]
pub const zts_errno_t_ZTS_ENOTCONN: zts_errno_t = 107;
#[doc = " Connection timed out"]
pub const zts_errno_t_ZTS_ETIMEDOUT: zts_errno_t = 110;
#[doc = " Connection timed out"]
pub const zts_errno_t_ZTS_ECONNREFUSED: zts_errno_t = 111;
#[doc = " No route to host"]
pub const zts_errno_t_ZTS_EHOSTUNREACH: zts_errno_t = 113;
#[doc = " Operation already in progress"]
pub const zts_errno_t_ZTS_EALREADY: zts_errno_t = 114;
#[doc = " Operation now in progress"]
pub const zts_errno_t_ZTS_EINPROGRESS: zts_errno_t = 115;
pub type zts_errno_t = ::std::os::raw::c_uint;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<accessx_descriptor>())).ad_name_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
pub type size_t = __darwin_size_t;
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
pub type uid_t = __darwin_uid_t;
pub type gid_t = __darwin_gid_t;
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type off_t = __darwin_off_t;
pub type pid_t = __darwin_pid_t;
pub type useconds_t = __darwin_useconds_t;
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type time_t = __darwin_time_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type sigset_t = __darwin_sigset_t;
extern "C" {
    #[link_name = "\u{1}_pselect$1050"]
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_select$1050"]
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
pub type zts_socklen_t = u32;
pub type zts_in_addr_t = u32;
pub type zts_in_port_t = u16;
pub type zts_sa_family_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_in_addr {
    pub s_addr: zts_in_addr_t,
}
#[test]
fn bindgen_test_layout_zts_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<zts_in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(zts_in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_in6_addr {
    pub un: zts_in6_addr_un,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union zts_in6_addr_un {
    pub u32_addr: [u32; 4usize],
    pub u8_addr: [u8; 16usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_zts_in6_addr_un() {
    assert_eq!(
        ::std::mem::size_of::<zts_in6_addr_un>(),
        16usize,
        concat!("Size of: ", stringify!(zts_in6_addr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_in6_addr_un>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_in6_addr_un))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in6_addr_un>())).u32_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in6_addr_un),
            "::",
            stringify!(u32_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in6_addr_un>())).u8_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in6_addr_un),
            "::",
            stringify!(u8_addr)
        )
    );
}
#[test]
fn bindgen_test_layout_zts_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<zts_in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(zts_in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in6_addr>())).un as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in6_addr),
            "::",
            stringify!(un)
        )
    );
}
#[doc = " Address structure to specify an IPv4 endpoint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_sockaddr_in {
    pub sin_len: u8,
    pub sin_family: zts_sa_family_t,
    pub sin_port: zts_in_port_t,
    pub sin_addr: zts_in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_zts_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<zts_sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(zts_sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[doc = " Address structure to specify an IPv6 endpoint"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_sockaddr_in6 {
    pub sin6_len: u8,
    pub sin6_family: zts_sa_family_t,
    pub sin6_port: zts_in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: zts_in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_zts_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<zts_sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(zts_sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
#[doc = " Pointers to socket address structures are often cast to this type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_sockaddr {
    pub sa_len: u8,
    pub sa_family: zts_sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_zts_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<zts_sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(zts_sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(zts_sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[doc = " Address structure large enough to hold IPv4 and IPv6 addresses"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_sockaddr_storage {
    pub s2_len: u8,
    pub ss_family: zts_sa_family_t,
    pub s2_data1: [::std::os::raw::c_char; 2usize],
    pub s2_data2: [u32; 3usize],
    pub s2_data3: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_zts_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<zts_sockaddr_storage>(),
        28usize,
        concat!("Size of: ", stringify!(zts_sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_sockaddr_storage>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_storage>())).s2_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_storage),
            "::",
            stringify!(s2_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_storage>())).s2_data1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_storage),
            "::",
            stringify!(s2_data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_storage>())).s2_data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_storage),
            "::",
            stringify!(s2_data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_sockaddr_storage>())).s2_data3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_sockaddr_storage),
            "::",
            stringify!(s2_data3)
        )
    );
}
#[doc = " Runtime details about the current node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_node_info_t {
    #[doc = " Node ID"]
    pub node_id: u64,
    #[doc = " Port used by ZeroTier to send and receive traffic"]
    pub port_primary: u16,
    #[doc = " Port used by ZeroTier to send and receive traffic"]
    pub port_secondary: u16,
    #[doc = " Port used by ZeroTier to send and receive traffic"]
    pub port_tertiary: u16,
    #[doc = " ZT Major version"]
    pub ver_major: u8,
    #[doc = " ZT Minor version"]
    pub ver_minor: u8,
    #[doc = " ZT Patch revision"]
    pub ver_rev: u8,
}
#[test]
fn bindgen_test_layout_zts_node_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_node_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(zts_node_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_node_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_node_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).node_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(node_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).port_primary as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(port_primary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).port_secondary as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(port_secondary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).port_tertiary as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(port_tertiary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).ver_major as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(ver_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).ver_minor as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(ver_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_node_info_t>())).ver_rev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_node_info_t),
            "::",
            stringify!(ver_rev)
        )
    );
}
#[doc = " Details about an assigned address that was added or removed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_addr_info_t {
    pub net_id: u64,
    pub addr: zts_sockaddr_storage,
}
#[test]
fn bindgen_test_layout_zts_addr_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_addr_info_t>(),
        40usize,
        concat!("Size of: ", stringify!(zts_addr_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_addr_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_addr_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_addr_info_t>())).net_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_addr_info_t),
            "::",
            stringify!(net_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_addr_info_t>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_addr_info_t),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " Waiting for network configuration (also means revision == 0)"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_REQUESTING_CONFIGURATION: zts_network_status_t =
    0;
#[doc = " Configuration received and we are authorized"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_OK: zts_network_status_t = 1;
#[doc = " Netconf master told us 'nope'"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_ACCESS_DENIED: zts_network_status_t = 2;
#[doc = " Netconf master exists, but this virtual network does not"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_NOT_FOUND: zts_network_status_t = 3;
#[doc = " Initialization of network failed or other internal error"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_PORT_ERROR: zts_network_status_t = 4;
#[doc = " ZeroTier core version too old"]
pub const zts_network_status_t_ZTS_NETWORK_STATUS_CLIENT_TOO_OLD: zts_network_status_t = 5;
#[doc = " Virtual network status codes"]
pub type zts_network_status_t = ::std::os::raw::c_uint;
#[doc = " Private networks are authorized via certificates of membership"]
pub const zts_net_info_type_t_ZTS_NETWORK_TYPE_PRIVATE: zts_net_info_type_t = 0;
#[doc = " Public networks have no access control -- they'll always be AUTHORIZED"]
pub const zts_net_info_type_t_ZTS_NETWORK_TYPE_PUBLIC: zts_net_info_type_t = 1;
#[doc = " Virtual network type codes"]
pub type zts_net_info_type_t = ::std::os::raw::c_uint;
#[doc = " A route to be pushed on a virtual network"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_route_info_t {
    #[doc = " Target network / netmask bits (in port field) or NULL or 0.0.0.0/0"]
    #[doc = " for default"]
    pub target: zts_sockaddr_storage,
    #[doc = " Gateway IP address (port ignored) or NULL (family == 0) for LAN-local"]
    #[doc = " (no gateway)"]
    pub via: zts_sockaddr_storage,
    #[doc = " Route flags"]
    pub flags: u16,
    #[doc = " Route metric (not currently used)"]
    pub metric: u16,
}
#[test]
fn bindgen_test_layout_zts_route_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_route_info_t>(),
        60usize,
        concat!("Size of: ", stringify!(zts_route_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_route_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_route_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_route_info_t>())).target as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_route_info_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_route_info_t>())).via as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_route_info_t),
            "::",
            stringify!(via)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_route_info_t>())).flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_route_info_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_route_info_t>())).metric as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_route_info_t),
            "::",
            stringify!(metric)
        )
    );
}
#[doc = " An Ethernet multicast group"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_multicast_group_t {
    #[doc = " MAC address (least significant 48 bits)"]
    pub mac: u64,
    #[doc = " Additional distinguishing information (usually zero)"]
    pub adi: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_zts_multicast_group_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_multicast_group_t>(),
        16usize,
        concat!("Size of: ", stringify!(zts_multicast_group_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_multicast_group_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_multicast_group_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_multicast_group_t>())).mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_multicast_group_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_multicast_group_t>())).adi as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_multicast_group_t),
            "::",
            stringify!(adi)
        )
    );
}
#[doc = " Ordinary node"]
pub const zts_peer_role_t_ZTS_PEER_ROLE_LEAF: zts_peer_role_t = 0;
#[doc = " Moon root"]
pub const zts_peer_role_t_ZTS_PEER_ROLE_MOON: zts_peer_role_t = 1;
#[doc = " Planetary root"]
pub const zts_peer_role_t_ZTS_PEER_ROLE_PLANET: zts_peer_role_t = 2;
#[doc = " The peer's trust hierarchy role"]
pub type zts_peer_role_t = ::std::os::raw::c_uint;
#[doc = " Virtual network configuration"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_net_info_t {
    #[doc = " 64-bit ZeroTier network ID"]
    pub net_id: u64,
    #[doc = " Ethernet MAC (48 bits) that should be assigned to port"]
    pub mac: u64,
    #[doc = " Network name (from network configuration master)"]
    pub name: [::std::os::raw::c_char; 128usize],
    #[doc = " Network configuration request status"]
    pub status: zts_network_status_t,
    #[doc = " Network type"]
    pub type_: zts_net_info_type_t,
    #[doc = " Maximum interface MTU"]
    pub mtu: ::std::os::raw::c_uint,
    #[doc = " If nonzero, the network this port belongs to indicates DHCP availability"]
    #[doc = ""]
    #[doc = " This is a suggestion. The underlying implementation is free to ignore it"]
    #[doc = " for security or other reasons. This is simply a netconf parameter that"]
    #[doc = " means 'DHCP is available on this network.'"]
    pub dhcp: ::std::os::raw::c_int,
    #[doc = " If nonzero, this port is allowed to bridge to other networks"]
    #[doc = ""]
    #[doc = " This is informational. If this is false (0), bridged packets will simply"]
    #[doc = " be dropped and bridging won't work."]
    pub bridge: ::std::os::raw::c_int,
    #[doc = " If nonzero, this network supports and allows broadcast"]
    #[doc = " (ff:ff:ff:ff:ff:ff) traffic"]
    pub broadcast_enabled: ::std::os::raw::c_int,
    #[doc = " If the network is in PORT_ERROR state, this is the (negative) error code"]
    #[doc = " most recently reported"]
    pub port_error: ::std::os::raw::c_int,
    #[doc = " Revision number as reported by controller or 0 if still waiting for"]
    #[doc = " config"]
    pub netconf_rev: ::std::os::raw::c_ulong,
    #[doc = " Number of assigned addresses"]
    pub assigned_addr_count: ::std::os::raw::c_uint,
    #[doc = " ZeroTier-assigned addresses (in sockaddr_storage structures)"]
    #[doc = ""]
    #[doc = " For IP, the port number of the sockaddr_XX structure contains the number"]
    #[doc = " of bits in the address netmask. Only the IP address and port are used."]
    #[doc = " Other fields like interface number can be ignored."]
    #[doc = ""]
    #[doc = " This is only used for ZeroTier-managed address assignments sent by the"]
    #[doc = " virtual network's configuration master."]
    pub assigned_addrs: [zts_sockaddr_storage; 16usize],
    #[doc = " Number of ZT-pushed routes"]
    pub route_count: ::std::os::raw::c_uint,
    #[doc = " Routes (excluding those implied by assigned addresses and their masks)"]
    pub routes: [zts_route_info_t; 32usize],
    #[doc = " Number of multicast groups subscribed"]
    pub multicast_sub_count: ::std::os::raw::c_uint,
    pub multicast_subs: [zts_net_info_t__bindgen_ty_1; 1024usize],
}
#[doc = " Multicast groups to which this network's device is subscribed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_net_info_t__bindgen_ty_1 {
    pub mac: u64,
    pub adi: u32,
}
#[test]
fn bindgen_test_layout_zts_net_info_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<zts_net_info_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(zts_net_info_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_net_info_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_net_info_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zts_net_info_t__bindgen_ty_1>())).mac as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t__bindgen_ty_1),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zts_net_info_t__bindgen_ty_1>())).adi as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t__bindgen_ty_1),
            "::",
            stringify!(adi)
        )
    );
}
#[test]
fn bindgen_test_layout_zts_net_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_net_info_t>(),
        18952usize,
        concat!("Size of: ", stringify!(zts_net_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_net_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_net_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).net_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(net_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).mac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).status as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).type_ as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).mtu as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).dhcp as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(dhcp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).bridge as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(bridge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zts_net_info_t>())).broadcast_enabled as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(broadcast_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).port_error as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(port_error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).netconf_rev as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(netconf_rev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zts_net_info_t>())).assigned_addr_count as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(assigned_addr_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).assigned_addrs as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(assigned_addrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).route_count as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(route_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).routes as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(routes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<zts_net_info_t>())).multicast_sub_count as *const _ as usize
        },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(multicast_sub_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_net_info_t>())).multicast_subs as *const _ as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_net_info_t),
            "::",
            stringify!(multicast_subs)
        )
    );
}
#[doc = " Physical network path to a peer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_path_t {
    #[doc = " Address of endpoint"]
    pub address: zts_sockaddr_storage,
    #[doc = " Time of last send in milliseconds or 0 for never"]
    pub last_tx: u64,
    #[doc = " Time of last receive in milliseconds or 0 for never"]
    pub last_rx: u64,
    #[doc = " Is this a trusted path? If so this will be its nonzero ID."]
    pub trusted_path_id: u64,
    #[doc = " One-way latency"]
    pub latency: f32,
    pub unused_0: f32,
    pub unused_1: f32,
    pub unused_2: f32,
    pub unused_3: f32,
    pub unused_4: f32,
    pub unused_5: u64,
    pub unused_6: u64,
    pub unused_7: f32,
    #[doc = " Name of physical interface (for monitoring)"]
    pub ifname: *mut ::std::os::raw::c_char,
    #[doc = " Is path expired?"]
    pub expired: ::std::os::raw::c_int,
    #[doc = " Is path preferred?"]
    pub preferred: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zts_path_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_path_t>(),
        120usize,
        concat!("Size of: ", stringify!(zts_path_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_path_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_path_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).last_tx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(last_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).last_rx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(last_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).trusted_path_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(trusted_path_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).latency as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_0 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_2 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_3 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_4 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_5 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_6 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).unused_7 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(unused_7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).ifname as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(ifname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).expired as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(expired)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_path_t>())).preferred as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_path_t),
            "::",
            stringify!(preferred)
        )
    );
}
#[doc = " Peer status result buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_peer_info_t {
    #[doc = " ZeroTier address (40 bits)"]
    pub peer_id: u64,
    #[doc = " Remote major version or -1 if not known"]
    pub ver_major: ::std::os::raw::c_int,
    #[doc = " Remote minor version or -1 if not known"]
    pub ver_minor: ::std::os::raw::c_int,
    #[doc = " Remote revision or -1 if not known"]
    pub ver_rev: ::std::os::raw::c_int,
    #[doc = " Last measured latency in milliseconds or -1 if unknown"]
    pub latency: ::std::os::raw::c_int,
    #[doc = " What trust hierarchy role does this device have?"]
    pub role: zts_peer_role_t,
    #[doc = " Number of paths (size of paths[])"]
    pub path_count: ::std::os::raw::c_uint,
    #[doc = " Whether this peer was ever reachable via an aggregate link"]
    pub unused_0: ::std::os::raw::c_int,
    #[doc = " Known network paths to peer"]
    pub paths: [zts_path_t; 16usize],
}
#[test]
fn bindgen_test_layout_zts_peer_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_peer_info_t>(),
        1960usize,
        concat!("Size of: ", stringify!(zts_peer_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_peer_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_peer_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).peer_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(peer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).ver_major as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(ver_major)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).ver_minor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(ver_minor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).ver_rev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(ver_rev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).latency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).role as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).path_count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(path_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).unused_0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(unused_0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_peer_info_t>())).paths as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_peer_info_t),
            "::",
            stringify!(paths)
        )
    );
}
#[doc = " Structure used to specify a root topology (aka a world)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_root_set_t {
    pub public_id_str: [*mut ::std::os::raw::c_char; 16usize],
    pub endpoint_ip_str: [[*mut ::std::os::raw::c_char; 32usize]; 16usize],
}
#[test]
fn bindgen_test_layout_zts_root_set_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_root_set_t>(),
        4224usize,
        concat!("Size of: ", stringify!(zts_root_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_root_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_root_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_root_set_t>())).public_id_str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_root_set_t),
            "::",
            stringify!(public_id_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_root_set_t>())).endpoint_ip_str as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_root_set_t),
            "::",
            stringify!(endpoint_ip_str)
        )
    );
}
#[doc = " Structure used to convey information about a virtual network"]
#[doc = " interface (netif) to a user application."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_netif_info_t {
    #[doc = " The virtual network that this interface was created for"]
    pub net_id: u64,
    #[doc = " The hardware address assigned to this interface"]
    pub mac: u64,
    #[doc = " The MTU for this interface"]
    pub mtu: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zts_netif_info_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_netif_info_t>(),
        24usize,
        concat!("Size of: ", stringify!(zts_netif_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_netif_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_netif_info_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_netif_info_t>())).net_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_netif_info_t),
            "::",
            stringify!(net_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_netif_info_t>())).mac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_netif_info_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_netif_info_t>())).mtu as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_netif_info_t),
            "::",
            stringify!(mtu)
        )
    );
}
#[doc = " Callback message"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_event_msg_t {
    #[doc = " Event identifier"]
    pub event_code: i16,
    #[doc = " Node status"]
    pub node: *mut zts_node_info_t,
    #[doc = " Network information"]
    pub network: *mut zts_net_info_t,
    #[doc = " Netif status"]
    pub netif: *mut zts_netif_info_t,
    #[doc = " Managed routes"]
    pub route: *mut zts_route_info_t,
    #[doc = " Peer info"]
    pub peer: *mut zts_peer_info_t,
    #[doc = " Assigned address"]
    pub addr: *mut zts_addr_info_t,
    #[doc = " Binary data (identities, planets, network configs, peer hints, etc)"]
    pub cache: *mut ::std::os::raw::c_void,
    #[doc = " Length of data message or structure"]
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zts_event_msg_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_event_msg_t>(),
        72usize,
        concat!("Size of: ", stringify!(zts_event_msg_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_event_msg_t>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_event_msg_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).event_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(event_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).node as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(node)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).network as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(network)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).netif as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(netif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).route as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).peer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(peer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).addr as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).cache as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_event_msg_t>())).len as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_event_msg_t),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " @brief Generates a node identity (public/secret key-pair) and stores it in a"]
    #[doc = "     user-provided buffer."]
    #[doc = ""]
    #[doc = " @param key User-provided destination buffer"]
    #[doc = " @param key_buf_len Length of user-provided destination buffer. Will be set"]
    #[doc = "     to the number of bytes copied."]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_id_new(
        key: *mut ::std::os::raw::c_char,
        key_buf_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Verifies that a key-pair is valid. Checks formatting and pairing of"]
    #[doc = "    key to address."]
    #[doc = ""]
    #[doc = " @param key Buffer containing key-pair"]
    #[doc = " @param len Length of key-pair buffer"]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_id_pair_is_valid(
        key: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instruct ZeroTier to look for node identity files at the given location. This is an"]
    #[doc = " initialization function that can only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " Note that calling this function is not mandatory and if it is not called the node's keys will be"]
    #[doc = " kept in memory and retrievable via `zts_node_get_id_pair()`."]
    #[doc = ""]
    #[doc = " See also: `zts_init_from_memory()`"]
    #[doc = ""]
    #[doc = " @param port Path Null-terminated file-system path string"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_from_storage(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Instruct ZeroTier to use the identity provided in `key`. This is an initialization"]
    #[doc = " function that can only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " Note that calling this function is not mandatory and if it is not called the node's keys will be"]
    #[doc = " kept in memory and retrievable via `zts_node_get_id_pair()`."]
    #[doc = ""]
    #[doc = " See also: `zts_init_from_storage()`"]
    #[doc = ""]
    #[doc = " @param key Path Null-terminated file-system path string"]
    #[doc = " @param len Length of `key` buffer"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_from_memory(
        key: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zts_init_set_event_handler(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Blacklist an interface prefix (or name). This prevents ZeroTier from"]
    #[doc = " sending traffic over matching interfaces. This is an initialization function that can"]
    #[doc = " only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param prefix Null-terminated interface prefix string"]
    #[doc = " @param len Length of prefix string"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_blacklist_if(
        prefix: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Present a root set definition for ZeroTier to use instead of the default."]
    #[doc = " This is an initialization function that can only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param roots_data Array of roots definition data (binary)"]
    #[doc = " @param len Length of binary data"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_set_roots(
        roots_data: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the port to which the node should bind. This is an initialization function that can"]
    #[doc = " only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param port Port number"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_set_port(port: ::std::os::raw::c_ushort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set range that random ports will be selected from. This is an initialization function that can"]
    #[doc = " only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param start_port Start of port range"]
    #[doc = " @param end_port End of port range"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_set_random_port_range(
        start_port: ::std::os::raw::c_ushort,
        end_port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allow or disallow ZeroTier from automatically selecting a backup port to help get through"]
    #[doc = " buggy NAT. This is enabled by default. This port is randomly chosen and should be disabled if you"]
    #[doc = " want to control exactly which ports ZeroTier talks on and (iff) you know with absolute certainty"]
    #[doc = " that traffic on your chosen primary port is allowed. This is an initialization function that can"]
    #[doc = " only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param port Port number"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_secondary_port(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Allow or disallow the use of port-mapping. This is enabled by default. This is an"]
    #[doc = " initialization function that can only be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param port Port number"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_port_mapping(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable whether the node will cache network details"]
    #[doc = " (enabled by default when `zts_init_from_storage()` is used.) Must be called before"]
    #[doc = " `zts_node_start()`."]
    #[doc = ""]
    #[doc = " This can potentially shorten (startup) times between node restarts. This allows the service to"]
    #[doc = " nearly instantly inform the network stack of an address to use for this peer"]
    #[doc = " so that it can create a transport service. This can be disabled for cases where one"]
    #[doc = " may not want network config details to be written to storage. This is"]
    #[doc = " especially useful for situations where address assignments do not change"]
    #[doc = " often."]
    #[doc = ""]
    #[doc = " See also: `zts_init_allow_peer_cache()`"]
    #[doc = ""]
    #[doc = " @param enabled Whether or not this feature is enabled"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_net_cache(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable whether the node will cache peer details (enabled"]
    #[doc = " by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " This can potentially shorten (connection) times between node restarts. This allows the service to"]
    #[doc = " re-use previously discovered paths to a peer, this prevents the service from"]
    #[doc = " having to go through the entire transport-triggered link provisioning"]
    #[doc = " process. This is especially useful for situations where paths to peers do not"]
    #[doc = " change often. This is enabled by default and can be disabled for cases where"]
    #[doc = " one may not want peer details to be written to storage."]
    #[doc = ""]
    #[doc = " See also: `zts_init_allow_net_cache()`"]
    #[doc = ""]
    #[doc = " @param enabled Whether or not this feature is enabled"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_peer_cache(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable whether the node will cache root definitions (enabled"]
    #[doc = " by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param enabled Whether or not this feature is enabled"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_roots_cache(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable whether the node will cache identities (enabled"]
    #[doc = " by default when `zts_init_from_storage()` is used.) Must be called before `zts_node_start()`."]
    #[doc = ""]
    #[doc = " @param enabled Whether or not this feature is enabled"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_init_allow_id_cache(allowed: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether an address of the given family has been assigned by the network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`"]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_addr_is_assigned(
        net_id: u64,
        family: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the first-assigned IP on the given network."]
    #[doc = ""]
    #[doc = " To get *all* assigned addresses on a given network, use `zts_addr_get_all()`."]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`"]
    #[doc = " @param addr Destination buffer to hold address"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_get(
        net_id: u64,
        family: ::std::os::raw::c_uint,
        addr: *mut zts_sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the first-assigned IP on the given network as a null-terminated human-readable string"]
    #[doc = ""]
    #[doc = " To get *all* assigned addresses on a given network, use `zts_addr_get_all()`."]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`"]
    #[doc = " @param dst Destination buffer"]
    #[doc = " @param len Length of destination buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_get_str(
        net_id: u64,
        family: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get all IP addresses assigned to this node by the given network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param addr Destination buffer to hold address"]
    #[doc = " @param count Number of addresses returned"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_get_all(
        net_id: u64,
        addr: *mut zts_sockaddr_storage,
        count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compute a `6PLANE` IPv6 address for the given Network ID and Node ID"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param node_id Node ID"]
    #[doc = " @param addr Destination structure for address"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_compute_6plane(
        net_id: u64,
        node_id: u64,
        addr: *mut zts_sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param node_id Node ID"]
    #[doc = " @param addr Destination structure for address"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_compute_rfc4193(
        net_id: u64,
        node_id: u64,
        addr: *mut zts_sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID and copy its"]
    #[doc = " null-terminated human-readable string representation into destination buffer."]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param node_id Node ID"]
    #[doc = " @param dst Destination string buffer"]
    #[doc = " @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_compute_rfc4193_str(
        net_id: u64,
        node_id: u64,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compute `6PLANE` IPv6 address for the given Network ID and Node ID and copy its"]
    #[doc = " null-terminated human-readable string representation into destination buffer."]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param node_id Node ID"]
    #[doc = " @param dst Destination string buffer"]
    #[doc = " @param len Length of destination string buffer (must be exactly `ZTS_IP_MAX_STR_LEN`)"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_addr_compute_6plane_str(
        net_id: u64,
        node_id: u64,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compute `RFC4193` IPv6 address for the given Network ID and Node ID"]
    #[doc = ""]
    #[doc = " Ad-hoc Network:"]
    #[doc = " ```"]
    #[doc = " ffSSSSEEEE000000"]
    #[doc = " | |   |   |"]
    #[doc = " | |   |   Reserved for future use, must be 0"]
    #[doc = " | |   End of port range (hex)"]
    #[doc = " | Start of port range (hex)"]
    #[doc = " Reserved ZeroTier address prefix indicating a controller-less network."]
    #[doc = " ```"]
    #[doc = " Ad-hoc networks are public (no access control) networks that have no network"]
    #[doc = " controller. Instead their configuration and other credentials are generated"]
    #[doc = " locally. Ad-hoc networks permit only IPv6 UDP and TCP unicast traffic"]
    #[doc = " (no multicast or broadcast) using 6plane format NDP-emulated IPv6 addresses."]
    #[doc = " In addition an ad-hoc network ID encodes an IP port range. UDP packets and"]
    #[doc = " TCP SYN (connection open) packets are only allowed to destination ports"]
    #[doc = " within the encoded range."]
    #[doc = ""]
    #[doc = " For example `ff00160016000000` is an ad-hoc network allowing only SSH,"]
    #[doc = " while `ff0000ffff000000` is an ad-hoc network allowing any UDP or TCP port."]
    #[doc = ""]
    #[doc = " Keep in mind that these networks are public and anyone in the entire world"]
    #[doc = " can join them. Care must be taken to avoid exposing vulnerable services or"]
    #[doc = " sharing unwanted files or other resources."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param start_port Start of port allowed port range"]
    #[doc = " @param end_port End of allowed port range"]
    #[doc = " @return An Ad-hoc network ID"]
    pub fn zts_net_compute_adhoc_id(start_port: u16, end_port: u16) -> u64;
}
extern "C" {
    #[doc = " @brief Join a network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_net_join(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Leave a network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_net_leave(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether this network is ready to send and receive traffic."]
    #[doc = ""]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_net_transport_is_ready(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the MAC Address for this node on the given network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = ""]
    #[doc = " @return MAC address in numerical format"]
    pub fn zts_net_get_mac(net_id: u64) -> u64;
}
extern "C" {
    #[doc = " @brief Get the MAC Address for this node on the given network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param dst Destination string buffer"]
    #[doc = " @param len Length of destination string buffer. Must be exactly `ZTS_MAC_ADDRSTRLEN`"]
    #[doc = ""]
    #[doc = " @return MAC address in string format"]
    pub fn zts_net_get_mac_str(
        net_id: u64,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether broadcast is enabled on this network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = ""]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_net_get_broadcast(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the MTU of the given network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = ""]
    #[doc = " @return MTU"]
    pub fn zts_net_get_mtu(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the nickname of the network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param dst Destination string buffer"]
    #[doc = " @param len Length of destination string buffer"]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_net_get_name(
        net_id: u64,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the status of the network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = ""]
    #[doc = " @return Status"]
    pub fn zts_net_get_status(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the type of network (public or private.)"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = ""]
    #[doc = " @return Type"]
    pub fn zts_net_get_type(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether a managed route of the given address family has been assigned by the"]
    #[doc = " network"]
    #[doc = ""]
    #[doc = " @param net_id Network ID"]
    #[doc = " @param family `ZTS_AF_INET`, or `ZTS_AF_INET6`"]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_route_is_assigned(
        net_id: u64,
        family: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Start the ZeroTier node. Should be called after calling the relevant"]
    #[doc = "    `zts_init_*` functions for your application. To enable storage call"]
    #[doc = "    `zts_init_from_storage()` before this function. To enable event callbacks"]
    #[doc = "     call `zts_init_set_event_handler()` before this function."]
    #[doc = ""]
    #[doc = " Note: If neither `zts_init_from_storage()` or `zts_init_from_memory()` are"]
    #[doc = " called a new identity will be generated and will be retrievable via"]
    #[doc = " `zts_node_get_id_pair()` *after* the node has started."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem."]
    pub fn zts_node_start() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether the node is online (Can reach the Internet)"]
    #[doc = ""]
    #[doc = " @return `1` if true, `0` if false."]
    pub fn zts_node_is_online() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the public node identity (aka `node_id`). Callable only after the node has been"]
    #[doc = " started."]
    #[doc = ""]
    #[doc = " @return Identity in numerical form"]
    pub fn zts_node_get_id() -> u64;
}
extern "C" {
    #[doc = " @brief Copy the current node's public (and secret!) identity into a buffer."]
    #[doc = ""]
    #[doc = " `WARNING`: This function exports your secret key and should be used carefully."]
    #[doc = ""]
    #[doc = " @param key User-provided destination buffer"]
    #[doc = " @param key_dst_len Length of user-provided destination buffer. Will be set to"]
    #[doc = " number of bytes copied."]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_node_get_id_pair(
        key: *mut ::std::os::raw::c_char,
        key_dst_len: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the primary port to which the node is bound. Callable only after the node has been"]
    #[doc = " started."]
    #[doc = ""]
    #[doc = " @return Port number"]
    pub fn zts_node_get_port() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Stop the ZeroTier node and bring down all virtual network"]
    #[doc = "     transport services. Callable only after the node has been started."]
    #[doc = ""]
    #[doc = " While the ZeroTier will stop, the stack driver (with associated"]
    #[doc = " timers) will remain active in case future traffic processing is required."]
    #[doc = " To stop all activity and free all resources use `zts_free()` instead."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem."]
    pub fn zts_node_stop() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Stop all background threads, bring down all transport services, free all"]
    #[doc = "     resources. After calling this function an application restart will be"]
    #[doc = "     required before the library can be used again. Callable only after the node"]
    #[doc = "     has been started."]
    #[doc = ""]
    #[doc = " This should be called at the end of your program or when you do not"]
    #[doc = " anticipate communicating over ZeroTier again."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem."]
    pub fn zts_node_free() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Orbit a given moon (user-defined root server)"]
    #[doc = ""]
    #[doc = " @param moon_roots_id World ID"]
    #[doc = " @param moon_seed Seed ID"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_moon_orbit(moon_roots_id: u64, moon_seed: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief De-orbit a given moon (user-defined root server)"]
    #[doc = ""]
    #[doc = " @param moon_roots_id World ID"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument."]
    pub fn zts_moon_deorbit(moon_roots_id: u64) -> ::std::os::raw::c_int;
}
#[doc = " Structure containing counters for various protocol statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_stats_counter_t {
    #[doc = " Number of link packets transmitted"]
    pub link_tx: u32,
    #[doc = " Number of link packets received"]
    pub link_rx: u32,
    #[doc = " Number of link packets dropped"]
    pub link_drop: u32,
    #[doc = " Aggregate number of link-level errors"]
    pub link_err: u32,
    #[doc = " Number of etharp packets transmitted"]
    pub etharp_tx: u32,
    #[doc = " Number of etharp packets received"]
    pub etharp_rx: u32,
    #[doc = " Number of etharp packets dropped"]
    pub etharp_drop: u32,
    #[doc = " Aggregate number of etharp errors"]
    pub etharp_err: u32,
    #[doc = " Number of IPv4 packets transmitted"]
    pub ip4_tx: u32,
    #[doc = " Number of IPv4 packets received"]
    pub ip4_rx: u32,
    #[doc = " Number of IPv4 packets dropped"]
    pub ip4_drop: u32,
    #[doc = " Aggregate number of IPv4 errors"]
    pub ip4_err: u32,
    #[doc = " Number of IPv6 packets transmitted"]
    pub ip6_tx: u32,
    #[doc = " Number of IPv6 packets received"]
    pub ip6_rx: u32,
    #[doc = " Number of IPv6 packets dropped"]
    pub ip6_drop: u32,
    #[doc = " Aggregate number of IPv6 errors"]
    pub ip6_err: u32,
    #[doc = " Number of ICMPv4 packets transmitted"]
    pub icmp4_tx: u32,
    #[doc = " Number of ICMPv4 packets received"]
    pub icmp4_rx: u32,
    #[doc = " Number of ICMPv4 packets dropped"]
    pub icmp4_drop: u32,
    #[doc = " Aggregate number of ICMPv4 errors"]
    pub icmp4_err: u32,
    #[doc = " Number of ICMPv6 packets transmitted"]
    pub icmp6_tx: u32,
    #[doc = " Number of ICMPv6 packets received"]
    pub icmp6_rx: u32,
    #[doc = " Number of ICMPv6 packets dropped"]
    pub icmp6_drop: u32,
    #[doc = " Aggregate number of ICMPv6 errors"]
    pub icmp6_err: u32,
    #[doc = " Number of UDP packets transmitted"]
    pub udp_tx: u32,
    #[doc = " Number of UDP packets received"]
    pub udp_rx: u32,
    #[doc = " Number of UDP packets dropped"]
    pub udp_drop: u32,
    #[doc = " Aggregate number of UDP errors"]
    pub udp_err: u32,
    #[doc = " Number of TCP packets transmitted"]
    pub tcp_tx: u32,
    #[doc = " Number of TCP packets received"]
    pub tcp_rx: u32,
    #[doc = " Number of TCP packets dropped"]
    pub tcp_drop: u32,
    #[doc = " Aggregate number of TCP errors"]
    pub tcp_err: u32,
    #[doc = " Number of ND6 packets transmitted"]
    pub nd6_tx: u32,
    #[doc = " Number of ND6 packets received"]
    pub nd6_rx: u32,
    #[doc = " Number of ND6 packets dropped"]
    pub nd6_drop: u32,
    #[doc = " Aggregate number of ND6 errors"]
    pub nd6_err: u32,
}
#[test]
fn bindgen_test_layout_zts_stats_counter_t() {
    assert_eq!(
        ::std::mem::size_of::<zts_stats_counter_t>(),
        144usize,
        concat!("Size of: ", stringify!(zts_stats_counter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_stats_counter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_stats_counter_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).link_tx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(link_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).link_rx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(link_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).link_drop as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(link_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).link_err as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(link_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).etharp_tx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(etharp_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).etharp_rx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(etharp_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).etharp_drop as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(etharp_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).etharp_err as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(etharp_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip4_tx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip4_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip4_rx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip4_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip4_drop as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip4_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip4_err as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip4_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip6_tx as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip6_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip6_rx as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip6_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip6_drop as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip6_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).ip6_err as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(ip6_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp4_tx as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp4_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp4_rx as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp4_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp4_drop as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp4_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp4_err as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp4_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp6_tx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp6_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp6_rx as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp6_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp6_drop as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp6_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).icmp6_err as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(icmp6_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).udp_tx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(udp_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).udp_rx as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(udp_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).udp_drop as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(udp_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).udp_err as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(udp_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).tcp_tx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(tcp_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).tcp_rx as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(tcp_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).tcp_drop as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(tcp_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).tcp_err as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(tcp_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).nd6_tx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(nd6_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).nd6_rx as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(nd6_rx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).nd6_drop as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(nd6_drop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_stats_counter_t>())).nd6_err as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_stats_counter_t),
            "::",
            stringify!(nd6_err)
        )
    );
}
extern "C" {
    #[doc = " @brief Get all statistical counters for all protocols and levels."]
    #[doc = " See also: lwip/stats.h."]
    #[doc = ""]
    #[doc = " This function can only be used in debug builds."]
    #[doc = ""]
    #[doc = " @param dst Pointer to structure that will be populated with statistics"]
    #[doc = ""]
    #[doc = " @return ZTS_ERR_OK on success. ZTS_ERR_ARG or ZTS_ERR_NO_RESULT on failure."]
    pub fn zts_stats_get_all(dst: *mut zts_stats_counter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a socket"]
    #[doc = ""]
    #[doc = " @param family `ZTS_AF_INET` or `ZTS_AF_INET6`"]
    #[doc = " @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`"]
    #[doc = " @param protocol Protocols supported on this socket"]
    #[doc = " @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_socket(
        family: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Connect a socket to a remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param addr Remote host address to connect to"]
    #[doc = " @param addrlen Length of address"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_connect(
        fd: ::std::os::raw::c_int,
        addr: *const zts_sockaddr,
        addrlen: zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Bind a socket to a local address"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param addr Local interface address to bind to"]
    #[doc = " @param addrlen Length of address"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_bind(
        fd: ::std::os::raw::c_int,
        addr: *const zts_sockaddr,
        addrlen: zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Listen for incoming connections on socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param backlog Number of backlogged connections allowed"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_listen(
        fd: ::std::os::raw::c_int,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Accept an incoming connection"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param addr Address of remote host for accepted connection"]
    #[doc = " @param addrlen Length of address"]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_accept(
        fd: ::std::os::raw::c_int,
        addr: *mut zts_sockaddr,
        addrlen: *mut zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zts_linger() {
    assert_eq!(
        ::std::mem::size_of::<zts_linger>(),
        8usize,
        concat!("Size of: ", stringify!(zts_linger))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_linger>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_ip_mreq {
    pub imr_multiaddr: zts_in_addr,
    pub imr_interface: zts_in_addr,
}
#[test]
fn bindgen_test_layout_zts_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<zts_ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(zts_ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_addr: zts_in_addr,
}
#[test]
fn bindgen_test_layout_zts_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<zts_in_pktinfo>(),
        8usize,
        concat!("Size of: ", stringify!(zts_in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_in_pktinfo>())).ipi_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_ipv6_mreq {
    pub ipv6mr_multiaddr: zts_in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_zts_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<zts_ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(zts_ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
extern "C" {
    #[doc = " @brief Set socket options."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param level Protocol level to which option name should apply"]
    #[doc = " @param optname Option name to set"]
    #[doc = " @param optval Source of option value to set"]
    #[doc = " @param optlen Length of option value"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_setsockopt(
        fd: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *const ::std::os::raw::c_void,
        optlen: zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get socket options."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param level Protocol level to which option name should apply"]
    #[doc = " @param optname Option name to get"]
    #[doc = " @param optval Where option value will be stored"]
    #[doc = " @param optlen Length of value"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_getsockopt(
        fd: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: *mut zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the name (address) of the local end of the socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param addr Name associated with this socket"]
    #[doc = " @param addrlen Length of name"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_getsockname(
        fd: ::std::os::raw::c_int,
        addr: *mut zts_sockaddr,
        addrlen: *mut zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the name (address) of the remote end of the socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param addr Name associated with remote end of this socket"]
    #[doc = " @param addrlen Length of name"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_getpeername(
        fd: ::std::os::raw::c_int,
        addr: *mut zts_sockaddr,
        addrlen: *mut zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Close socket."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_fd_set {
    pub fd_bits: [::std::os::raw::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_zts_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<zts_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(zts_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_fd_set>(),
        1usize,
        concat!("Alignment of ", stringify!(zts_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_fd_set>())).fd_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_fd_set),
            "::",
            stringify!(fd_bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_timeval {
    pub tv_sec: ::std::os::raw::c_long,
    pub tv_usec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_zts_timeval() {
    assert_eq!(
        ::std::mem::size_of::<zts_timeval>(),
        16usize,
        concat!("Size of: ", stringify!(zts_timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
extern "C" {
    #[doc = " @brief Monitor multiple file descriptors for \"readiness\""]
    #[doc = ""]
    #[doc = " @param nfds Set to the highest numbered file descriptor in any of the given"]
    #[doc = " sets"]
    #[doc = " @param readfds Set of file descriptors to monitor for READ readiness"]
    #[doc = " @param writefds Set of file descriptors to monitor for WRITE readiness"]
    #[doc = " @param exceptfds Set of file descriptors to monitor for exceptional"]
    #[doc = " conditions"]
    #[doc = " @param timeout How long this call should block"]
    #[doc = " @return Number of ready file descriptors on success. `ZTS_ERR_SOCKET`,"]
    #[doc = " `ZTS_ERR_SERVICE` on failure. Sets `zts_errno`"]
    pub fn zts_bsd_select(
        nfds: ::std::os::raw::c_int,
        readfds: *mut zts_fd_set,
        writefds: *mut zts_fd_set,
        exceptfds: *mut zts_fd_set,
        timeout: *mut zts_timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Issue file control commands on a socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param cmd Operation to be performed"]
    #[doc = " @param flags Flags"]
    #[doc = " @return"]
    pub fn zts_bsd_fcntl(
        fd: ::std::os::raw::c_int,
        cmd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type zts_nfds_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_zts_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<zts_pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(zts_pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_pollfd),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " @brief Wait for some event on a file descriptor."]
    #[doc = ""]
    #[doc = " @param fds Set of file descriptors to monitor"]
    #[doc = " @param nfds Number of elements in the fds array"]
    #[doc = " @param timeout How long this call should block"]
    #[doc = " @return Number of ready file descriptors if successful, `ZTS_ERR_SERVICE` if"]
    #[doc = " the node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets"]
    #[doc = " `zts_errno`"]
    pub fn zts_bsd_poll(
        fds: *mut zts_pollfd,
        nfds: zts_nfds_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Control a device"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param request Selects the control function to be performed"]
    #[doc = " @param argp Additional information"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_ioctl(
        fd: ::std::os::raw::c_int,
        request: ::std::os::raw::c_ulong,
        argp: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send data to remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data to write"]
    #[doc = " @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)"]
    #[doc = " @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_send(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Send data to remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data to write"]
    #[doc = " @param flags Specifies type of message transmission"]
    #[doc = " @param addr Destination address"]
    #[doc = " @param addrlen Length of destination address"]
    #[doc = " @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_sendto(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
        addr: *const zts_sockaddr,
        addrlen: zts_socklen_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_zts_iovec() {
    assert_eq!(
        ::std::mem::size_of::<zts_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(zts_iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: zts_socklen_t,
    pub msg_iov: *mut zts_iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: zts_socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_zts_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<zts_msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(zts_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_msghdr>())).msg_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
extern "C" {
    #[doc = " @brief Send message to remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param msg Message to send"]
    #[doc = " @param flags Specifies type of message transmission"]
    #[doc = " @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_sendmsg(
        fd: ::std::os::raw::c_int,
        msg: *const zts_msghdr,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Receive data from remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data buffer"]
    #[doc = " @param flags Specifies the type of message receipt"]
    #[doc = " @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_recv(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Receive data from remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data buffer"]
    #[doc = " @param flags Specifies the type of message receipt"]
    #[doc = " @param addr Destination address buffer"]
    #[doc = " @param addrlen Length of destination address buffer"]
    #[doc = " @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_recvfrom(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
        addr: *mut zts_sockaddr,
        addrlen: *mut zts_socklen_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Receive a message from remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param msg Message that was received"]
    #[doc = " @param flags Specifies the type of message receipt"]
    #[doc = " @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_recvmsg(
        fd: ::std::os::raw::c_int,
        msg: *mut zts_msghdr,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read data from socket onto buffer"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data buffer to receive data"]
    #[doc = " @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_read(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read data from socket into multiple buffers"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param iov Array of destination buffers"]
    #[doc = " @param iovcnt Number of buffers to read into"]
    #[doc = " @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_readv(
        fd: ::std::os::raw::c_int,
        iov: *const zts_iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write data from buffer to socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of buffer to write"]
    #[doc = " @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write data from multiple buffers to socket."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param iov Array of source buffers"]
    #[doc = " @param iovcnt Number of buffers to read from"]
    #[doc = " @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_writev(
        fd: ::std::os::raw::c_int,
        iov: *const zts_iovec,
        iovcnt: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Shut down some aspect of a socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param how Which aspects of the socket should be shut down. Options are `ZTS_SHUT_RD`,"]
    #[doc = " `ZTS_SHUT_WR`, or `ZTS_SHUT_RDWR`."]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bsd_shutdown(
        fd: ::std::os::raw::c_int,
        how: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a socket"]
    #[doc = ""]
    #[doc = " @param family `ZTS_AF_INET` or `ZTS_AF_INET6`"]
    #[doc = " @param type `ZTS_SOCK_STREAM` or `ZTS_SOCK_DGRAM`"]
    #[doc = " @param protocol Protocols supported on this socket"]
    #[doc = " @return Numbered file descriptor on success, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_socket(
        family: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Connect a socket to a remote host"]
    #[doc = ""]
    #[doc = " This convenience function exists because ZeroTier uses transport-triggered"]
    #[doc = " links. This means that links between peers do not exist until peers try to"]
    #[doc = " talk to each other. This can be a problem during connection procedures since"]
    #[doc = " some of the initial packets are lost. To alleviate the need to try"]
    #[doc = " `zts_bsd_connect` many times, this function will keep re-trying for you, even if"]
    #[doc = " no known routes exist. However, if the socket is set to `non-blocking` mode"]
    #[doc = " it will behave identically to `zts_bsd_connect` and return immediately upon"]
    #[doc = " failure."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param ipstr Human-readable IP string"]
    #[doc = " @param port Port"]
    #[doc = " @param timeout_ms (Approximate) amount of time in milliseconds before"]
    #[doc = "     connection attempt is aborted. Will block for `30 seconds` if timeout is"]
    #[doc = "     set to `0`."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SOCKET` if the function times"]
    #[doc = "     out with no connection made, `ZTS_ERR_SERVICE` if the node experiences a"]
    #[doc = "     problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_connect(
        fd: ::std::os::raw::c_int,
        ipstr: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Bind a socket to a local address"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param ipstr Human-readable IP string"]
    #[doc = " @param port Port"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_bind(
        fd: ::std::os::raw::c_int,
        ipstr: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Listen for incoming connections on socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param backlog Number of backlogged connections allowed"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_listen(
        fd: ::std::os::raw::c_int,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Accept an incoming connection"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param remote_addr Buffer that will receive remote host IP string"]
    #[doc = " @param len Size of buffer that will receive remote host IP string"]
    #[doc = "     (must be exactly `ZTS_IP_MAX_STR_LEN`)"]
    #[doc = " @param port Port number of the newly connected remote host (value-result)"]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_accept(
        fd: ::std::os::raw::c_int,
        remote_addr: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        port: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Send data to remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data to write"]
    #[doc = " @param flags (e.g. `ZTS_MSG_DONTWAIT`, `ZTS_MSG_MORE`)"]
    #[doc = " @return Number of bytes sent if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_send(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Receive data from remote host"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data buffer"]
    #[doc = " @param flags Specifies the type of message receipt"]
    #[doc = " @return Number of bytes received if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_recv(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
        flags: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Read data from socket onto buffer"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of data buffer to receive data"]
    #[doc = " @return Number of bytes read if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_read(
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Write data from buffer to socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param buf Pointer to data buffer"]
    #[doc = " @param len Length of buffer to write"]
    #[doc = " @return Number of bytes written if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
    ) -> ssize_t;
}
extern "C" {
    #[doc = " @brief Shut down `read` aspect of a socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_shutdown_rd(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shut down `write` aspect of a socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_shutdown_wr(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Shut down both `read` and `write` aspect of a socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_shutdown_rdwr(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Close socket."]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the name (address) of the remote end of the socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param remote_addr_str Destination buffer to contain name (address) of the remote end of the socket"]
    #[doc = " @param len Length of destination buffer"]
    #[doc = " @param port Value-result parameter that will contain resultant port number"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_getpeername(
        fd: ::std::os::raw::c_int,
        remote_addr_str: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        port: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the name (address) of the local end of the socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param local_addr_str Destination buffer to contain name (address) of the local end of the socket"]
    #[doc = " @param len Length of destination buffer"]
    #[doc = " @param port Value-result parameter that will contain resultant port number"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_getsockname(
        fd: ::std::os::raw::c_int,
        local_addr_str: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        port: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief A convenience function that takes a remote address IP string and creates"]
    #[doc = " the appropriate type of socket, and uses it to connect to a remote host."]
    #[doc = ""]
    #[doc = " @param remote_ipstr Remote address string. IPv4 or IPv6"]
    #[doc = " @param remote_port Port to"]
    #[doc = ""]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_tcp_client(
        remote_ipstr: *const ::std::os::raw::c_char,
        remote_port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief A convenience function that takes a remote address IP string and creates"]
    #[doc = " the appropriate type of socket, binds, listens, and then accepts on it."]
    #[doc = ""]
    #[doc = " @param local_ipstr Local address to bind"]
    #[doc = " @param local_port Local port to bind"]
    #[doc = " @param remote_ipstr String-format IP address of newly connected remote host"]
    #[doc = " @param len Length of `remote_ipstr`"]
    #[doc = " @param remote_port Port of remote host"]
    #[doc = ""]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_tcp_server(
        local_ipstr: *const ::std::os::raw::c_char,
        local_port: ::std::os::raw::c_ushort,
        remote_ipstr: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        remote_port: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief A convenience function that takes a remote address IP string and creates"]
    #[doc = " the appropriate type of socket, and binds to it."]
    #[doc = ""]
    #[doc = " @param local_ipstr Local address to bind"]
    #[doc = " @param local_port Local port to bind"]
    #[doc = ""]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_udp_server(
        local_ipstr: *const ::std::os::raw::c_char,
        local_port: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief This function doesn't really do anything other than be a namespace"]
    #[doc = " counterpart to `zts_udp_server`. All this function does is create a"]
    #[doc = " `ZTS_SOCK_DGRAM` socket and return its file descriptor."]
    #[doc = ""]
    #[doc = " @param remote_ipstr Remote address string. IPv4 or IPv6"]
    #[doc = ""]
    #[doc = " @return New file descriptor if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_udp_client(remote_ipstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable `TCP_NODELAY`. Enabling this is equivalent to"]
    #[doc = "     turning off Nagle's algorithm"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param enabled `[0, 1]` integer value"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_no_delay(
        fd: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the last error for the given socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Error number defined in `zts_errno_t`. `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_last_socket_error(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return amount of data available to read from socket"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Number of bytes available to read. `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_data_available(fd: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    #[doc = " @brief Return whether `TCP_NODELAY` is enabled"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_no_delay(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable `SO_LINGER` while also setting its value"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param enabled `[0, 1]` integer value"]
    #[doc = " @param value How long socket should linger"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_linger(
        fd: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether `SO_LINGER` is enabled"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_linger_enabled(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `SO_LINGER`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `SO_LINGER` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_linger_value(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the number of bytes available to read from the network buffer"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Number of bytes to read if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_pending_data_size(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable `SO_REUSEADDR`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param enabled `[0, 1]` integer value"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_reuse_addr(
        fd: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether `SO_REUSEADDR` is enabled"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_reuse_addr(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of `SO_RCVTIMEO`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param seconds Number of seconds for timeout"]
    #[doc = " @param microseconds Number of microseconds for timeout"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_recv_timeout(
        fd: ::std::os::raw::c_int,
        seconds: ::std::os::raw::c_int,
        microseconds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `SO_RCVTIMEO`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `SO_RCVTIMEO` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_recv_timeout(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of `SO_SNDTIMEO`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param seconds Number of seconds for timeout"]
    #[doc = " @param microseconds Number of microseconds for timeout"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_send_timeout(
        fd: ::std::os::raw::c_int,
        seconds: ::std::os::raw::c_int,
        microseconds: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `SO_SNDTIMEO`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `SO_SNDTIMEO` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_send_timeout(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of `SO_SNDBUF`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param size Size of buffer"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_send_buf_size(
        fd: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `SO_SNDBUF`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `SO_SNDBUF` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_send_buf_size(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of `SO_RCVBUF`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param size Size of buffer"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_recv_buf_size(
        fd: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `SO_RCVBUF`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `SO_RCVBUF` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_recv_buf_size(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the value of `IP_TTL`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param ttl Value of `IP_TTL`"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_ttl(
        fd: ::std::os::raw::c_int,
        ttl: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the value of `IP_TTL`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return Value of `IP_TTL` `[0,255]` if successful, `ZTS_ERR_SERVICE` if the"]
    #[doc = " node experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_ttl(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Change blocking behavior `O_NONBLOCK`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param enabled `[0, 1]` integer value, `1` maintains default behavior,"]
    #[doc = "     `0` sets to non-blocking mode"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_blocking(
        fd: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether blocking mode `O_NONBLOCK` is enabled"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_blocking(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Enable or disable `SO_KEEPALIVE`"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @param enabled `[0, 1]` integer value"]
    #[doc = " @return `ZTS_ERR_OK` if successful, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_set_keepalive(
        fd: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return whether `SO_KEEPALIVE` is enabled"]
    #[doc = ""]
    #[doc = " @param fd Socket file descriptor"]
    #[doc = " @return `1` if enabled, `0` if disabled, `ZTS_ERR_SERVICE` if the node"]
    #[doc = "     experiences a problem, `ZTS_ERR_ARG` if invalid argument. Sets `zts_errno`"]
    pub fn zts_get_keepalive(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_zts_hostent() {
    assert_eq!(
        ::std::mem::size_of::<zts_hostent>(),
        32usize,
        concat!("Size of: ", stringify!(zts_hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(zts_hostent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_hostent>())).h_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_hostent),
            "::",
            stringify!(h_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_hostent>())).h_aliases as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_hostent),
            "::",
            stringify!(h_aliases)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_hostent>())).h_addrtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_hostent),
            "::",
            stringify!(h_addrtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_hostent>())).h_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_hostent),
            "::",
            stringify!(h_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_hostent>())).h_addr_list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_hostent),
            "::",
            stringify!(h_addr_list)
        )
    );
}
extern "C" {
    #[doc = " @brief Resolve a host-name"]
    #[doc = ""]
    #[doc = " @param name A null-terminated string representing the name of the host"]
    #[doc = " @return Pointer to struct zts_hostent if successful, NULL otherwise"]
    pub fn zts_bsd_gethostbyname(name: *const ::std::os::raw::c_char) -> *mut zts_hostent;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_ip4_addr {
    pub addr: u32,
}
#[test]
fn bindgen_test_layout_zts_ip4_addr() {
    assert_eq!(
        ::std::mem::size_of::<zts_ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(zts_ip4_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ip4_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip4_addr>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip4_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " This is the aligned version of ip6_addr_t,"]
#[doc = "used as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zts_ip6_addr {
    pub addr: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_zts_ip6_addr() {
    assert_eq!(
        ::std::mem::size_of::<zts_ip6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(zts_ip6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ip6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ip6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip6_addr>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip6_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " A union struct for both IP version's addresses."]
#[doc = " ATTENTION: watch out for its size when adding IPv6 address scope!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zts_ip_addr {
    pub u_addr: zts_ip_addr__bindgen_ty_1,
    pub type_: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union zts_ip_addr__bindgen_ty_1 {
    pub ip6: zts_ip6_addr,
    pub ip4: zts_ip4_addr,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_zts_ip_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<zts_ip_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(zts_ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ip_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_addr__bindgen_ty_1>())).ip6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_addr__bindgen_ty_1>())).ip4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
}
#[test]
fn bindgen_test_layout_zts_ip_addr() {
    assert_eq!(
        ::std::mem::size_of::<zts_ip_addr>(),
        20usize,
        concat!("Size of: ", stringify!(zts_ip_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<zts_ip_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(zts_ip_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_addr>())).u_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_addr),
            "::",
            stringify!(u_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<zts_ip_addr>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zts_ip_addr),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " Initialize one of the DNS servers."]
    #[doc = ""]
    #[doc = " @param index the index of the DNS server to set must be `< DNS_MAX_SERVERS`"]
    #[doc = " @param addr IP address of the DNS server to set"]
    pub fn zts_dns_set_server(index: u8, addr: *const zts_ip_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obtain one of the currently configured DNS server."]
    #[doc = ""]
    #[doc = " @param index the index of the DNS server"]
    #[doc = " @return IP address of the indexed DNS server or `ip_addr_any` if the DNS"]
    #[doc = "         server has not been configured."]
    pub fn zts_dns_get_server(index: u8) -> *const zts_ip_addr;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_lock_obtain() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_lock_release() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_addr_count(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_addr(
        net_id: u64,
        idx: ::std::os::raw::c_uint,
        addr: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_route_count(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_route(
        net_id: u64,
        idx: ::std::os::raw::c_uint,
        target: *mut ::std::os::raw::c_char,
        via: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
        flags: *mut u16,
        metric: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_path_count(peer_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_path(
        peer_id: u64,
        idx: ::std::os::raw::c_uint,
        dst: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_mc_count(net_id: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Lock the core service so that queries about addresses, routes, paths, etc. can be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " Notice: Core locking functions are intended to be used by high-level language wrappers."]
    #[doc = " Only lock the core if you know *exactly* what you are doing. zts_core_lock_obtain() and"]
    #[doc = " zts_core_lock_release() must be called before and after this function."]
    #[doc = ""]
    #[doc = " @return `ZTS_ERR_OK` if successful. `ZTS_ERR_SERVICE` if the core service is unavailable."]
    pub fn zts_core_query_mc(
        net_id: u64,
        idx: ::std::os::raw::c_uint,
        mac: *mut u64,
        adi: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Generates a new root set definition"]
    #[doc = ""]
    #[doc = " @param roots_id The desired World ID (arbitrary)"]
    #[doc = " @param ts Timestamp indicating when this generation took place"]
    pub fn zts_util_sign_root_set(
        roots_out: *mut ::std::os::raw::c_char,
        roots_len: *mut ::std::os::raw::c_uint,
        prev_key: *mut ::std::os::raw::c_char,
        prev_key_len: *mut ::std::os::raw::c_uint,
        curr_key: *mut ::std::os::raw::c_char,
        curr_key_len: *mut ::std::os::raw::c_uint,
        id: u64,
        ts: u64,
        roots_spec: *mut zts_root_set_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Platform-agnostic delay"]
    #[doc = ""]
    #[doc = " @param milliseconds How long to delay"]
    pub fn zts_util_delay(milliseconds: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " @brief Return the family type of the IP string"]
    #[doc = ""]
    #[doc = " @param ipstr Either IPv4 or IPv6 string"]
    #[doc = " @return Either `ZTS_AF_INET` or `ZTS_AF_INET6`"]
    pub fn zts_util_get_ip_family(ipstr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert human-friendly IP string to `zts_sockaddr_in` or `zts_sockaddr_in6`."]
    #[doc = ""]
    #[doc = " @param src_ipstr Source IP string"]
    #[doc = " @param port Port"]
    #[doc = " @param dstaddr Pointer to destination structure `zts_sockaddr_in` or"]
    #[doc = " `zts_sockaddr_in6`"]
    #[doc = " @param addrlen Size of destination structure. Value-result: Will be set to"]
    #[doc = " actual size of data available"]
    #[doc = " @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument"]
    pub fn zts_util_ipstr_to_saddr(
        src_ipstr: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_ushort,
        dstaddr: *mut zts_sockaddr,
        addrlen: *mut zts_socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Similar to `inet_ntop` but determines family automatically and returns"]
    #[doc = " port as a value result parameter."]
    #[doc = ""]
    #[doc = " @param addr Pointer to address structure"]
    #[doc = " @param addrlen Length of address structure"]
    #[doc = " @param dst_str Destination buffer"]
    #[doc = " @param len Length of destination buffer"]
    #[doc = " @param port Value-result parameter that will contain resultant port number"]
    #[doc = ""]
    #[doc = " @return return `ZTS_ERR_OK` on success, `ZTS_ERR_ARG` if invalid argument"]
    pub fn zts_util_ntop(
        addr: *mut zts_sockaddr,
        addrlen: zts_socklen_t,
        dst_str: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        port: *mut ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert numeric IP address (both versions) into `ASCII` representation."]
    #[doc = " returns ptr to static buffer. Not reentrant."]
    #[doc = ""]
    #[doc = " @param addr IP address in network order to convert"]
    #[doc = " @return Pointer to a global static (!) buffer that holds the `ASCII`"]
    #[doc = "         representation of addr"]
    pub fn zts_ipaddr_ntoa(addr: *const zts_ip_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert IP address string (both versions) to numeric."]
    #[doc = " The version is auto-detected from the string."]
    #[doc = ""]
    #[doc = " @param cp IP address string to convert"]
    #[doc = " @param addr conversion result is stored here"]
    #[doc = " @return `1` on success, `0` on error"]
    pub fn zts_ipaddr_aton(
        cp: *const ::std::os::raw::c_char,
        addr: *mut zts_ip_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert IPv4 and IPv6 address structures to human-readable text form."]
    #[doc = ""]
    #[doc = " @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`"]
    #[doc = " @param src Pointer to source address structure"]
    #[doc = " @param dst Pointer to destination character array"]
    #[doc = " @param size Size of the destination buffer"]
    #[doc = " @return On success, returns a non-null pointer to the destination character"]
    #[doc = " array"]
    pub fn zts_inet_ntop(
        family: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_void,
        dst: *mut ::std::os::raw::c_char,
        size: zts_socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert C-string IPv4 and IPv6 addresses to binary form."]
    #[doc = ""]
    #[doc = " @param family Address family: `ZTS_AF_INET` or `ZTS_AF_INET6`"]
    #[doc = " @param src Pointer to source character array"]
    #[doc = " @param dst Pointer to destination address structure"]
    #[doc = " @return return `1` on success. `0` or `-1` on failure. (Does not follow regular"]
    #[doc = " `zts_*` conventions)"]
    pub fn zts_inet_pton(
        family: ::std::os::raw::c_int,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
