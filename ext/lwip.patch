diff --git a/src/api/sockets.c b/src/api/sockets.c
index 2d231739..a0c24829 100644
--- a/src/api/sockets.c
+++ b/src/api/sockets.c
@@ -38,6 +38,7 @@
  */
 
 #include "lwip/opt.h"
+#include "ZeroTierConstants.h"
 
 #if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
 
@@ -281,6 +282,7 @@ static struct lwip_select_cb *select_cb_list;
 #define sock_set_errno(sk, e) do { \
   const int sockerr = (e); \
   set_errno(sockerr); \
+  zts_errno = sockerr; \
 } while (0)
 
 /* Forward declaration of some functions */
diff --git a/src/core/ipv6/nd6.c b/src/core/ipv6/nd6.c
index 039b7963..6647c90c 100644
--- a/src/core/ipv6/nd6.c
+++ b/src/core/ipv6/nd6.c
@@ -1644,9 +1644,27 @@ nd6_is_prefix_in_netif(const ip6_addr_t *ip6addr, struct netif *netif)
    * addresses (from autoconfiguration) have no implied subnet assignment, and
    * are thus effectively /128 assignments. See RFC 5942 for more on this. */
   for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
-    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
+    /*if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
         netif_ip6_addr_isstatic(netif, i) &&
-        ip6_addr_netcmp(ip6addr, netif_ip6_addr(netif, i))) {
+        ip6_addr_netcmp(ip6addr, netif_ip6_addr(netif, i))) {*/
+      int prefix_match = 0;
+    if (ip6_addr_is_zt_6plane(ip6addr)) {
+      prefix_match = ip6_addr_6plane_cmp(ip6addr, netif_ip6_addr(netif, i));
+      DEBUG_INFO("6plane, prefix_match=%d", prefix_match);
+    }
+    if (ip6_addr_is_zt_adhoc(ip6addr)) {
+      prefix_match = ip6_addr_adhoc_cmp(ip6addr, netif_ip6_addr(netif, i));
+      DEBUG_INFO("adhoc, prefix_match=%d", prefix_match);
+    }
+    if (ip6_addr_is_zt_rfc4193(ip6addr)) {
+      prefix_match = ip6_addr_rfc4193_cmp(ip6addr, netif_ip6_addr(netif, i));
+      DEBUG_INFO("rfc4193, prefix_match=%d", prefix_match);
+    }
+    if (!prefix_match) {
+      prefix_match = ip6_addr_netcmp(ip6addr, netif_ip6_addr(netif, i));
+      DEBUG_INFO("traditional match, prefix_match=%d", prefix_match);
+    }
+    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) && prefix_match) {
       return 1;
     }
   }
diff --git a/src/include/lwip/ip6_addr.h b/src/include/lwip/ip6_addr.h
index 29c2a34d..205b0e1f 100644
--- a/src/include/lwip/ip6_addr.h
+++ b/src/include/lwip/ip6_addr.h
@@ -160,6 +160,28 @@ typedef struct ip6_addr ip6_addr_t;
 #define ip6_addr_netcmp(addr1, addr2) (ip6_addr_netcmp_zoneless((addr1), (addr2)) && \
                                        ip6_addr_cmp_zone((addr1), (addr2)))
 
+/* Determine if an address *could* be a ZeroTier 6PLANE address */
+#define ip6_addr_is_zt_6plane(addr1) (((addr1)->addr[0] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xfc000000UL))
+
+/* Compare first 40 bits of address (ff + first 32 bits of nwid XOR'd with second 32 bits of nwid) */
+#define ip6_addr_6plane_cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                    ((addr1)->addr[1] & PP_HTONL(0xff000000UL)) == ((addr2)->addr[1] & PP_HTONL(0xff000000UL)))
+
+/* Determine if an address *could* be a ZeroTier Ad-hoc address */
+#define ip6_addr_is_zt_adhoc(addr1) (((addr1)->addr[0] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xff000000UL))
+
+/* Compare first 40 bits of address (ff + first 32 bits of nwid XOR'd with second 32 bits of nwid) */
+#define ip6_addr_adhoc_cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                    ((addr1)->addr[1] & PP_HTONL(0xff000000UL)) == ((addr2)->addr[1] & PP_HTONL(0xff000000UL)))
+
+/* Determine if an address *could* be an RFC4193 address */
+#define ip6_addr_is_zt_rfc4193(addr1) (((addr1)->addr[0] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xfd000000UL))
+
+/* Compare first 72 bits of address (fd + 64 bits of nwid) */
+#define ip6_addr_rfc4193_cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                    ((addr1)->addr[1] == (addr2)->addr[1]) && \
+                                    ((addr1)->addr[2] & PP_HTONL(0xff000000UL)) == ((addr2)->addr[2] & PP_HTONL(0xff000000UL)))
+
 /* Exact-host comparison *after* ip6_addr_netcmp() succeeded, for efficiency. */
 #define ip6_addr_nethostcmp(addr1, addr2) (((addr1)->addr[2] == (addr2)->addr[2]) && \
                                            ((addr1)->addr[3] == (addr2)->addr[3]))
